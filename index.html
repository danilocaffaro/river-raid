<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>River Raid v3 - Atari 2600 Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        #gameCanvas {
            border: 4px solid #444;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            z-index: 10;
        }
        .hidden { display: none !important; }
        .title {
            font-size: 48px;
            color: #ff6600;
            text-shadow: 4px 4px #880000;
            margin-bottom: 20px;
            letter-spacing: 4px;
        }
        .version {
            font-size: 14px;
            color: #ff6600;
            margin-top: -15px;
            margin-bottom: 15px;
        }
        .subtitle {
            font-size: 18px;
            color: #66ff66;
            margin-bottom: 30px;
        }
        .instructions {
            font-size: 14px;
            color: #aaa;
            text-align: center;
            line-height: 1.8;
            margin-bottom: 30px;
        }
        .instructions span {
            color: #ffff00;
        }
        .start-btn {
            font-size: 24px;
            color: #00ffff;
            cursor: pointer;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }
        .high-score {
            font-size: 16px;
            color: #ff00ff;
            margin-top: 20px;
        }
        .game-over-title {
            font-size: 36px;
            color: #ff0000;
            margin-bottom: 20px;
        }
        .final-score {
            font-size: 24px;
            color: #ffff00;
            margin-bottom: 10px;
        }
        .pause-text {
            font-size: 48px;
            color: #ffff00;
        }
        /* v3: Speed settings panel */
        .settings-panel {
            margin-bottom: 20px;
            padding: 15px 20px;
            border: 2px solid #ff6600;
            background: rgba(20, 10, 0, 0.8);
            text-align: center;
            min-width: 280px;
        }
        .settings-panel h3 {
            color: #ff6600;
            font-size: 14px;
            margin-bottom: 12px;
            letter-spacing: 2px;
        }
        .slider-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .slider-row label {
            color: #66ff66;
            font-size: 12px;
            min-width: 90px;
            text-align: left;
        }
        .slider-row input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 120px;
            height: 8px;
            background: #333;
            border-radius: 0;
            outline: none;
            border: 1px solid #ff6600;
        }
        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 18px;
            background: #00ffff;
            border: 1px solid #008888;
            cursor: pointer;
        }
        .slider-row input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 18px;
            background: #00ffff;
            border: 1px solid #008888;
            cursor: pointer;
            border-radius: 0;
        }
        .slider-val {
            color: #00ffff;
            font-size: 12px;
            min-width: 35px;
            text-align: right;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="overlay">
        <div id="startScreen">
            <div class="title">RIVER RAID</div>
            <div class="version">v3</div>
            <div class="subtitle">Atari 2600 Clone</div>
            <div class="instructions">
                <span>← → or A D</span> : Move Left/Right<br>
                <span>↑ ↓ or W S</span> : Speed Up/Down<br>
                <span>SPACE</span> : Shoot<br>
                <span>P</span> : Pause<br><br>
                Destroy enemies, refuel at depots<br>
                Avoid riverbanks and bridges!<br>
                <span>Touch controls available on mobile</span>
            </div>
            <div class="settings-panel">
                <h3>⚙ SPEED SETTINGS</h3>
                <div class="slider-row">
                    <label>SCROLL SPD</label>
                    <input type="range" id="scrollSpeedSlider" min="0.5" max="6" step="0.1" value="1.8">
                    <span class="slider-val" id="scrollSpeedVal">1.8</span>
                </div>
                <div class="slider-row">
                    <label>BULLET SPD</label>
                    <input type="range" id="bulletSpeedSlider" min="3" max="15" step="0.5" value="7">
                    <span class="slider-val" id="bulletSpeedVal">7</span>
                </div>
            </div>
            <div class="start-btn" id="startBtn">PRESS SPACE OR TAP TO START</div>
            <div class="high-score" id="highScoreDisplay">HIGH SCORE: 0</div>
        </div>
        <div id="pauseScreen" class="hidden">
            <div class="pause-text">PAUSED</div>
            <div class="instructions" style="margin-top: 20px;">Press P or tap to resume</div>
        </div>
        <div id="gameOverScreen" class="hidden">
            <div class="game-over-title">GAME OVER</div>
            <div class="final-score" id="finalScore">SCORE: 0</div>
            <div class="high-score" id="newHighScore" class="hidden">NEW HIGH SCORE!</div>
            <div class="start-btn" id="restartBtn" style="margin-top: 20px;">PRESS SPACE OR TAP TO RESTART</div>
        </div>
    </div>

    <script>
        // ==================== GAME CONFIGURATION ====================
        const CONFIG = {
            CANVAS_WIDTH: 480,
            CANVAS_HEIGHT: 640,
            PLAYER_WIDTH: 15,  // 5px sprite * 3 scale
            PLAYER_HEIGHT: 27, // 9px sprite * 3 scale
            BULLET_WIDTH: 4,
            BULLET_HEIGHT: 12,
            BULLET_SPEED: 7,
            FUEL_DEPLETION_RATE: 0.15,
            FUEL_REFILL_RATE: 1.5,
            INITIAL_LIVES: 3,
            INVINCIBILITY_FRAMES: 120,
            BASE_SCROLL_SPEED: 1.8,
            MAX_SCROLL_SPEED: 4,
            MIN_SCROLL_SPEED: 0.5,
            RIVER_MIN_WIDTH: 120,
            RIVER_MAX_WIDTH: 280,
            DIFFICULTY_INCREASE_INTERVAL: 1000,
            ISLAND_INTERVAL: 15 // sections between islands
        };

        // v3: Speed settings from localStorage
        (function loadSpeedSettings() {
            const savedScroll = localStorage.getItem('riverRaidScrollSpeed');
            const savedBullet = localStorage.getItem('riverRaidBulletSpeed');
            if (savedScroll !== null) CONFIG.BASE_SCROLL_SPEED = parseFloat(savedScroll);
            if (savedBullet !== null) CONFIG.BULLET_SPEED = parseFloat(savedBullet);
            // Scale max/min proportionally based on base
            const ratio = CONFIG.BASE_SCROLL_SPEED / 1.8;
            CONFIG.MAX_SCROLL_SPEED = 4 * ratio;
            CONFIG.MIN_SCROLL_SPEED = Math.max(0.3, 0.5 * ratio);
        })();

        // ==================== ATARI 2600 COLOR PALETTE (pixel-accurate from gameplay) ====================
        const COLORS = {
            SKY: '#000000',
            RIVER: '#5d6ae8',       // Atari periwinkle blue (from actual gameplay)
            RIVER_DARK: '#4050c8',
            RIVER_LIGHT: '#7080f0',
            BANK_LEFT: '#7da354',   // Medium olive green (from gameplay)
            BANK_RIGHT: '#6e8e2d',  // Darker olive
            BANK_DETAIL: '#8fb862',
            BANK_DETAIL2: '#9dc870',
            BANK_ROCK: '#8a7040',
            PLAYER: '#f3d44d',      // Warm yellow (pixel-sampled from gameplay)
            PLAYER_WING: '#d4b030',
            PLAYER_COCKPIT: '#0c0c0c',  // Black cockpit detail (authentic!)
            BULLET: '#f3d44d',      // Same yellow as player
            HELICOPTER: '#0f2d67',  // Dark navy/blue (actual gameplay color!)
            HELICOPTER_BLADE: '#f5d04a', // Yellow rotor blade
            JET: '#b0b0b0',        // Light gray
            JET_WING: '#909090',
            JET_FLAME: '#ff4400',
            SHIP: '#c84e3b',       // Red/brick hull (from gameplay!)
            SHIP_DECK: '#0a0a0a',  // Black deck/superstructure
            FUEL_DEPOT: '#ff8cc9', // Bright pink/magenta (from gameplay)
            FUEL_TANK: '#c67bdd',  // Light purple
            BRIDGE: '#a0581f',     // Brown planks (from gameplay)
            BRIDGE_DETAIL: '#6b2f00', // Dark brown plank detail
            ISLAND: '#7da354',
            ISLAND_DETAIL: '#8fb862',
            EXPLOSION: ['#ffffff', '#ffff44', '#ffaa00', '#ff4400', '#ff0000', '#880000'],
            HUD_BG: '#cfcfcf',     // Light gray HUD (from gameplay)
            HUD_TEXT: '#f1d95f',    // Warm yellow text (from gameplay)
            FUEL_FULL: '#22ff22',
            FUEL_MED: '#ffff22',
            FUEL_LOW: '#ff2222',
            WATER_SHIMMER: '#7080f0'
        };

        // ==================== ATARI 2600 AUTHENTIC PIXEL SPRITE DATA ====================
        // Recreated from the official Atari 2600 sprite sheet
        // Each sprite is a 2D array of color keys (null = transparent)
        // PX = canvas pixels per Atari pixel

        const PX = 3; // base pixel scale (larger for smaller authentic sprites)

        // Player airplane: 5 wide x 9 tall — white/gray jet pointing UP (Atari 2600 authentic)
        const SPRITE_PLAYER = [
            [null,null,'W',null,null],        // nose tip (1px white)
            [null,'W','W','W',null],          // nose (3px)
            [null,'G','W','G',null],          // cockpit (white center, gray sides)
            ['W','G','G','G','W'],            // upper fuselage (gray body, white edges)
            ['W','W','W','W','W'],            // main wings (5px full white)
            [null,'G','G','G',null],          // mid fuselage
            [null,'W','G','W',null],          // engine section
            [null,null,'G',null,null],        // tail root
            [null,'W',null,'W',null],         // twin tail fins
        ];

        // Enemy jet: 9 wide x 7 tall — same shape as player but gray, pointing DOWN
        const SPRITE_JET = [
            [null,null,null,null,'J',null,null,null,null],  // nose tip
            [null,null,null,'J','J','J',null,null,null],    // nose taper
            [null,null,'J','J','J','J','J',null,null],      // leading edge
            ['A','A','J','J','C','J','J','A','A'],          // main wings + cockpit highlight
            [null,null,'J','J','J','J','J',null,null],      // wing root
            [null,null,null,'J','J','J',null,null,null],    // upper fuselage
            [null,null,null,null,'J',null,null,null,null],  // tail
        ];

        // Helicopter: 7 wide x 4 tall — dark navy blue body, yellow rotor, white window (pixel-accurate!)
        const SPRITE_HELI = [
            [null,null,'R','R',null,null,null],             // yellow rotor (2px)
            [null,null,'B','B','B',null,null],              // top body
            [null,'K','B','W','B','K',null],                // body + white window + black tail
            [null,null,'B','B','B',null,null],              // bottom body / skids
        ];

        // Ship/tanker: 9 wide x 3 tall — black deck, red hull, green shadow (pixel-accurate!)
        const SPRITE_SHIP = [
            [null,null,null,'K','K','K',null,null,null],    // black deck/superstructure
            [null,null,'R','R','R','R','R',null,null],      // red hull
            [null,null,'V','V','V','V','V',null,null],      // green underside shadow
        ];

        // Fuel depot: 5 wide x 10 tall — pink/magenta bg, vertical "FUEL" text (pixel-accurate!)
        const SPRITE_FUEL = [
            ['P','P','P','P','P'],
            ['P','M','M','M','P'],  // F
            ['P','M','P','P','P'],
            ['P','M','M','P','P'],  // U
            ['P','M','P','M','P'],
            ['P','M','M','M','P'],  // E
            ['P','M','P','P','P'],
            ['P','M','M','P','P'],  // L
            ['P','M','P','M','P'],
            ['P','P','P','P','P'],
        ];

        // Color maps for each sprite type (pixel-sampled from actual gameplay)
        const PLAYER_COLORS = { 'W': '#e8e8e8', 'G': '#a0a0a0' }; // white/gray jet (authentic)
        const JET_COLORS = { 'J': '#888888', 'A': '#666666', 'C': '#aaaaaa' };
        const HELI_COLORS = { 'B': '#0f2d67', 'R': '#f5d04a', 'W': '#ffffff', 'K': '#050505' };
        const SHIP_COLORS = { 'K': '#0a0a0a', 'R': '#c84e3b', 'V': '#6e8e2d' };
        const FUEL_COLORS = { 'P': '#ff8cc9', 'M': '#1e2a8e' };

        function drawPixelSprite(ctx, sprite, colorMap, x, y, pxSize) {
            for (let row = 0; row < sprite.length; row++) {
                for (let col = 0; col < sprite[row].length; col++) {
                    const c = sprite[row][col];
                    if (c && colorMap[c]) {
                        ctx.fillStyle = colorMap[c];
                        ctx.fillRect(
                            Math.round(x + col * pxSize),
                            Math.round(y + row * pxSize),
                            pxSize, pxSize
                        );
                    }
                }
            }
        }

        // ==================== AUDIO ENGINE ====================
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.initialized = false;
                this.engineOsc = null;
                this.engineGain = null;
            }

            init() {
                if (this.initialized) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                    this.startEngine();
                } catch (e) {
                    console.warn('Audio not available');
                }
            }

            startEngine() {
                if (!this.ctx) return;
                this.engineOsc = this.ctx.createOscillator();
                this.engineGain = this.ctx.createGain();
                this.engineOsc.type = 'sawtooth';
                this.engineOsc.frequency.value = 60;
                this.engineGain.gain.value = 0.03;
                this.engineOsc.connect(this.engineGain);
                this.engineGain.connect(this.ctx.destination);
                this.engineOsc.start();
            }

            updateEngineSpeed(speed) {
                if (this.engineOsc) {
                    this.engineOsc.frequency.value = 40 + speed * 15;
                }
            }

            playShoot() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 880;
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.03);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.08);
            }

            playExplosion() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.3;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const noise = this.ctx.createBufferSource();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();
                noise.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.15);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            playEnemyHit() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, this.ctx.currentTime);
                osc.frequency.setTargetAtTime(220, this.ctx.currentTime, 0.05);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }

            playFuelWarning() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 660;
                gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.08);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            playRefuel() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(330, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(660, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime + 0.1, 0.05);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playDeath() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(440, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(55, this.ctx.currentTime + 0.5);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime + 0.3, 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.6);
            }

            playBridgeDestroy() {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 0.5);
                }
                const noise = this.ctx.createBufferSource();
                const filter = this.ctx.createBiquadFilter();
                const gain = this.ctx.createGain();
                noise.buffer = buffer;
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime + 0.3, 0.1);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            }

            playHelicopterDestroy() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.15);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.25);
            }

            playJetDestroy() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.15);
                gain.gain.setValueAtTime(0.25, this.ctx.currentTime);
                gain.gain.setTargetAtTime(0.001, this.ctx.currentTime, 0.1);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            playSectionComplete() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0, t + i * 0.08);
                    gain.gain.linearRampToValueAtTime(0.15, t + i * 0.08 + 0.02);
                    gain.gain.setTargetAtTime(0.001, t + i * 0.08 + 0.06, 0.03);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start(t + i * 0.08);
                    osc.stop(t + i * 0.08 + 0.12);
                });
            }

            setMuted(muted) {
                if (this.engineGain) {
                    this.engineGain.gain.value = muted ? 0 : 0.03;
                }
            }
        }

        // ==================== GAME STATE ====================
        class GameState {
            constructor() {
                this.reset();
            }

            reset() {
                this.score = 0;
                this.lives = CONFIG.INITIAL_LIVES;
                this.fuel = 100;
                this.scrollSpeed = CONFIG.BASE_SCROLL_SPEED;
                this.scrollOffset = 0;
                this.difficulty = 1;
                this.distanceTraveled = 0;
                this.isPlaying = false;
                this.isPaused = false;
                this.isGameOver = false;
                this.invincibilityFrames = 0;
                this.fuelWarningTimer = 0;
                this.section = 1;
                this.sectionFlash = 0;
                this.waterPhase = 0;
            }
        }

        // ==================== PLAYER ====================
        class Player {
            constructor() {
                this.reset();
            }

            reset() {
                this.x = CONFIG.CANVAS_WIDTH / 2;
                this.y = CONFIG.CANVAS_HEIGHT - 100;
                this.width = CONFIG.PLAYER_WIDTH;
                this.height = CONFIG.PLAYER_HEIGHT;
                this.speed = 5;
                this.bullets = [];
                this.shootCooldown = 0;
            }

            update(keys, riverLeft, riverRight, touchInput) {
                if (keys['ArrowLeft'] || keys['KeyA']) {
                    this.x -= this.speed;
                }
                if (keys['ArrowRight'] || keys['KeyD']) {
                    this.x += this.speed;
                }

                if (touchInput) {
                    if (touchInput.moveLeft) this.x -= this.speed;
                    if (touchInput.moveRight) this.x += this.speed;
                }

                const margin = 5;
                this.x = Math.max(riverLeft + margin, Math.min(riverRight - this.width - margin, this.x));

                if (this.shootCooldown > 0) this.shootCooldown--;
                if ((keys['Space'] || keys['KeyX'] || (touchInput && touchInput.shoot)) && this.shootCooldown === 0) {
                    this.shoot();
                    this.shootCooldown = 10;
                }

                this.bullets = this.bullets.filter(b => {
                    b.y -= CONFIG.BULLET_SPEED;
                    return b.y > -CONFIG.BULLET_HEIGHT;
                });
            }

            shoot() {
                this.bullets.push({
                    x: this.x + this.width / 2 - CONFIG.BULLET_WIDTH / 2,
                    y: this.y - CONFIG.BULLET_HEIGHT,
                    width: CONFIG.BULLET_WIDTH,
                    height: CONFIG.BULLET_HEIGHT
                });
                audio.playShoot();
            }

            draw(ctx, invincible) {
                const alpha = invincible && Math.floor(Date.now() / 50) % 2 ? 0.3 : 1;
                ctx.globalAlpha = alpha;

                // v3: Atari 2600 pixel art player
                drawPixelSprite(ctx, SPRITE_PLAYER, PLAYER_COLORS, this.x, this.y, PX);

                ctx.globalAlpha = 1;

                // Bullets
                ctx.fillStyle = COLORS.BULLET;
                this.bullets.forEach(b => {
                    ctx.fillRect(b.x, b.y, b.width, b.height);
                });
            }

            getBounds() {
                return {
                    x: this.x + 8,
                    y: this.y + 5,
                    width: this.width - 16,
                    height: this.height - 10
                };
            }
        }

        // ==================== RIVER GENERATOR ====================
        class RiverGenerator {
            constructor() {
                this.segments = [];
                this.segmentHeight = 20;
                this.currentLeftTarget = 100;
                this.currentRightTarget = CONFIG.CANVAS_WIDTH - 100;
                this.leftEdge = 100;
                this.rightEdge = CONFIG.CANVAS_WIDTH - 100;
                this.changeTimer = 0;
                this.changeInterval = 50;
                this.islands = [];
                this.islandSpawnCounter = 0;
            }

            reset() {
                this.segments = [];
                this.leftEdge = 100;
                this.rightEdge = CONFIG.CANVAS_WIDTH - 100;
                this.currentLeftTarget = 100;
                this.currentRightTarget = CONFIG.CANVAS_WIDTH - 100;
                this.islands = [];
                this.islandSpawnCounter = 0;

                for (let y = CONFIG.CANVAS_HEIGHT; y >= -this.segmentHeight; y -= this.segmentHeight) {
                    this.segments.push({
                        y: y,
                        left: this.leftEdge,
                        right: this.rightEdge
                    });
                }
            }

            update(scrollSpeed, difficulty, section) {
                this.segments.forEach(s => s.y += scrollSpeed);
                this.segments = this.segments.filter(s => s.y < CONFIG.CANVAS_HEIGHT + this.segmentHeight);

                while (this.segments.length === 0 || this.segments[0].y > -this.segmentHeight) {
                    this.changeTimer++;

                    if (this.changeTimer >= this.changeInterval) {
                        this.changeTimer = 0;
                        this.changeInterval = 20 + Math.random() * 30; // More frequent changes

                        // Atari 2600 authentic: extreme width variation (very narrow to wide)
                        const minWidth = Math.max(100, CONFIG.RIVER_MIN_WIDTH - difficulty * 8);
                        const maxWidth = CONFIG.RIVER_MAX_WIDTH + 20 - difficulty * 2;
                        const targetWidth = minWidth + Math.random() * (maxWidth - minWidth);

                        const center = 100 + Math.random() * (CONFIG.CANVAS_WIDTH - 200);
                        this.currentLeftTarget = center - targetWidth / 2;
                        this.currentRightTarget = center + targetWidth / 2;

                        this.currentLeftTarget = Math.max(30, this.currentLeftTarget);
                        this.currentRightTarget = Math.min(CONFIG.CANVAS_WIDTH - 30, this.currentRightTarget);
                    }

                    // Atari 2600 authentic: abrupt changes, irregular margins (not smooth lerp)
                    const changeRate = 0.15 + Math.random() * 0.1; // faster, more erratic
                    this.leftEdge += (this.currentLeftTarget - this.leftEdge) * changeRate;
                    this.rightEdge += (this.currentRightTarget - this.rightEdge) * changeRate;
                    
                    // Add jitter for dentated/irregular margins
                    this.leftEdge += (Math.random() - 0.5) * 8;
                    this.rightEdge += (Math.random() - 0.5) * 8;

                    const newY = this.segments.length > 0 ? this.segments[0].y - this.segmentHeight : -this.segmentHeight;
                    this.segments.unshift({
                        y: newY,
                        left: this.leftEdge,
                        right: this.rightEdge
                    });
                }

                this.islands.forEach(isl => {
                    isl.y += scrollSpeed;
                });
                this.islands = this.islands.filter(isl => isl.y < CONFIG.CANVAS_HEIGHT + 100);
            }

            spawnIsland() {
                const bounds = this.getRiverBoundsAtY(0);
                const riverWidth = bounds.right - bounds.left;
                if (riverWidth < 140) return;

                const islandWidth = Math.min(riverWidth * 0.35, 80);
                const islandHeight = 200 + Math.random() * 150;
                const islandX = bounds.left + (riverWidth - islandWidth) / 2;

                this.islands.push({
                    x: islandX,
                    y: -islandHeight,
                    width: islandWidth,
                    height: islandHeight,
                    treeOffsets: Array.from({length: 8}, () => ({
                        dx: Math.random() * 0.8 + 0.1,
                        dy: Math.random() * 0.8 + 0.1,
                        size: 4 + Math.random() * 6
                    }))
                });
            }

            draw(ctx, waterPhase) {
                this.segments.forEach((seg, i) => {
                    const nextSeg = this.segments[i + 1] || seg;

                    ctx.fillStyle = COLORS.BANK_LEFT;
                    ctx.beginPath();
                    ctx.moveTo(0, seg.y);
                    ctx.lineTo(seg.left, seg.y);
                    ctx.lineTo(nextSeg.left, seg.y + this.segmentHeight);
                    ctx.lineTo(0, seg.y + this.segmentHeight);
                    ctx.fill();

                    ctx.fillStyle = COLORS.BANK_RIGHT;
                    ctx.beginPath();
                    ctx.moveTo(seg.right, seg.y);
                    ctx.lineTo(CONFIG.CANVAS_WIDTH, seg.y);
                    ctx.lineTo(CONFIG.CANVAS_WIDTH, seg.y + this.segmentHeight);
                    ctx.lineTo(nextSeg.right, seg.y + this.segmentHeight);
                    ctx.fill();

                    const waveOffset = Math.sin((seg.y + waterPhase) * 0.05) * 0.5 + 0.5;
                    const baseColor = (Math.floor((seg.y + waterPhase * 0.3) / 40) % 2 === 0);
                    ctx.fillStyle = baseColor ? COLORS.RIVER : COLORS.RIVER_DARK;
                    ctx.beginPath();
                    ctx.moveTo(seg.left, seg.y);
                    ctx.lineTo(seg.right, seg.y);
                    ctx.lineTo(nextSeg.right, seg.y + this.segmentHeight);
                    ctx.lineTo(nextSeg.left, seg.y + this.segmentHeight);
                    ctx.fill();

                    if (Math.floor((seg.y + waterPhase) / 60) % 3 === 0) {
                        ctx.fillStyle = COLORS.WATER_SHIMMER;
                        const shimmerX = seg.left + (seg.right - seg.left) * (0.2 + waveOffset * 0.3);
                        ctx.fillRect(shimmerX, seg.y, 12 + waveOffset * 8, 2);
                    }
                });

                for (let y = 0; y < CONFIG.CANVAS_HEIGHT; y += 20) {
                    const seg = this.getSegmentAtY(y);
                    if (seg) {
                        for (let x = 8; x < seg.left - 8; x += 20) {
                            const hash = (x * 7 + y * 13) % 100;
                            if (hash < 30) {
                                ctx.fillStyle = COLORS.BANK_DETAIL;
                                ctx.fillRect(x, y, 6, 6);
                            } else if (hash < 45) {
                                ctx.fillStyle = COLORS.BANK_DETAIL2;
                                ctx.fillRect(x, y, 4, 4);
                            } else if (hash < 52) {
                                ctx.fillStyle = '#ffff44';
                                ctx.fillRect(x + 1, y, 2, 2);
                            } else if (hash < 58) {
                                ctx.fillStyle = COLORS.BANK_ROCK;
                                ctx.fillRect(x, y + 2, 5, 3);
                            }
                        }
                        for (let x = seg.right + 8; x < CONFIG.CANVAS_WIDTH - 8; x += 20) {
                            const hash = (x * 11 + y * 17) % 100;
                            if (hash < 30) {
                                ctx.fillStyle = COLORS.BANK_DETAIL;
                                ctx.fillRect(x, y, 6, 6);
                            } else if (hash < 45) {
                                ctx.fillStyle = COLORS.BANK_DETAIL2;
                                ctx.fillRect(x, y, 4, 4);
                            } else if (hash < 52) {
                                ctx.fillStyle = '#ff6688';
                                ctx.fillRect(x + 1, y, 2, 2);
                            } else if (hash < 58) {
                                ctx.fillStyle = COLORS.BANK_ROCK;
                                ctx.fillRect(x, y + 2, 5, 3);
                            }
                        }
                    }
                }

                this.islands.forEach(isl => {
                    ctx.fillStyle = COLORS.ISLAND;
                    const taper = 6;
                    ctx.fillRect(isl.x + taper, isl.y, isl.width - taper * 2, isl.height);
                    ctx.fillRect(isl.x, isl.y + 15, isl.width, isl.height - 30);
                    ctx.fillRect(isl.x + taper / 2, isl.y + 5, isl.width - taper, isl.height - 10);

                    isl.treeOffsets.forEach(t => {
                        ctx.fillStyle = COLORS.ISLAND_DETAIL;
                        const tx = isl.x + t.dx * isl.width;
                        const ty = isl.y + t.dy * isl.height;
                        ctx.fillRect(tx, ty, t.size, t.size);
                    });
                });
            }

            getSegmentAtY(y) {
                return this.segments.find(s => y >= s.y && y < s.y + this.segmentHeight);
            }

            getRiverBoundsAtY(y) {
                const seg = this.getSegmentAtY(y);
                if (seg) {
                    return { left: seg.left, right: seg.right };
                }
                return { left: 100, right: CONFIG.CANVAS_WIDTH - 100 };
            }

            isInsideIsland(x, y, width, height) {
                for (const isl of this.islands) {
                    if (x + width > isl.x && x < isl.x + isl.width &&
                        y + height > isl.y && y < isl.y + isl.height) {
                        return true;
                    }
                }
                return false;
            }
        }

        // ==================== ENEMIES ====================
        class EnemyManager {
            constructor() {
                this.enemies = [];
                this.spawnTimer = 0;
                this.bridgeSpawnTimer = 0;
                this.jetSpawnTimer = 0;
            }

            reset() {
                this.enemies = [];
                this.spawnTimer = 0;
                this.bridgeSpawnTimer = 0;
                this.jetSpawnTimer = 0;
            }

            update(scrollSpeed, difficulty, river, section) {
                this.spawnTimer++;
                this.bridgeSpawnTimer++;
                this.jetSpawnTimer++;

                const spawnRate = Math.max(30, 80 - difficulty * 3);
                const bridgeRate = Math.max(200, 400 - difficulty * 10);
                const jetRate = Math.max(60, 150 - section * 5);

                if (this.spawnTimer >= spawnRate) {
                    this.spawnTimer = 0;
                    this.spawnEnemy(river, difficulty);
                }

                if (this.bridgeSpawnTimer >= bridgeRate) {
                    this.bridgeSpawnTimer = 0;
                    this.spawnBridge(river);
                }

                if (section >= 2 && this.jetSpawnTimer >= jetRate) {
                    this.jetSpawnTimer = 0;
                    this.spawnJet(river, difficulty, section);
                }

                this.enemies.forEach(e => {
                    if (e.type === 'jet') {
                        e.y += e.speed;
                        e.zigzagPhase += e.zigzagSpeed;
                        e.x += Math.sin(e.zigzagPhase) * e.zigzagAmplitude;

                        const bounds = river.getRiverBoundsAtY(e.y);
                        e.x = Math.max(bounds.left + 5, Math.min(bounds.right - e.width - 5, e.x));
                    } else {
                        e.y += scrollSpeed;

                        if (e.type === 'helicopter') {
                            e.x += e.dx;
                            const bounds = river.getRiverBoundsAtY(e.y);
                            if (e.x <= bounds.left + 10 || e.x >= bounds.right - e.width - 10) {
                                e.dx *= -1;
                            }
                            e.bladeAngle = (e.bladeAngle + 0.3) % (Math.PI * 2);
                        } else if (e.type === 'ship') {
                            e.x += e.dx * 0.5;
                            const bounds = river.getRiverBoundsAtY(e.y);
                            if (e.x <= bounds.left + 10 || e.x >= bounds.right - e.width - 10) {
                                e.dx *= -1;
                            }
                        }
                    }
                });

                this.enemies = this.enemies.filter(e => e.y < CONFIG.CANVAS_HEIGHT + 50 && e.y > -100);
            }

            spawnEnemy(river, difficulty) {
                const bounds = river.getRiverBoundsAtY(0);
                const riverWidth = bounds.right - bounds.left;
                const types = ['helicopter', 'helicopter', 'ship', 'fuel'];
                const type = types[Math.floor(Math.random() * types.length)];

                let enemy = {
                    type: type,
                    y: -50,
                    health: 1
                };

                switch (type) {
                    case 'helicopter':
                        enemy.width = 21;
                        enemy.height = 12;
                        enemy.x = bounds.left + 20 + Math.random() * (riverWidth - enemy.width - 40);
                        enemy.dx = (Math.random() > 0.5 ? 1 : -1) * (1 + difficulty * 0.2);
                        enemy.bladeAngle = 0;
                        enemy.points = 60;
                        break;
                    case 'ship':
                        enemy.width = 27;
                        enemy.height = 9;
                        enemy.x = bounds.left + 20 + Math.random() * (riverWidth - enemy.width - 40);
                        enemy.dx = (Math.random() > 0.5 ? 1 : -1) * 0.8;
                        enemy.points = 30;
                        break;
                    case 'fuel':
                        enemy.width = 15;
                        enemy.height = 30;
                        enemy.x = bounds.left + 20 + Math.random() * (riverWidth - enemy.width - 40);
                        enemy.dx = 0;
                        enemy.points = 80;
                        enemy.isFuel = true;
                        break;
                }

                this.enemies.push(enemy);
            }

            spawnJet(river, difficulty, section) {
                const bounds = river.getRiverBoundsAtY(0);
                const riverWidth = bounds.right - bounds.left;

                this.enemies.push({
                    type: 'jet',
                    x: bounds.left + 20 + Math.random() * (riverWidth - 48),
                    y: -40,
                    width: 27,
                    height: 21,
                    health: 1,
                    points: 100,
                    speed: 3 + Math.min(section * 0.3, 4),
                    zigzagPhase: Math.random() * Math.PI * 2,
                    zigzagSpeed: 0.06 + Math.random() * 0.04,
                    zigzagAmplitude: 1.5 + Math.random() * 1.5,
                    flameFlicker: 0
                });
            }

            spawnBridge(river) {
                const bounds = river.getRiverBoundsAtY(0);
                this.enemies.push({
                    type: 'bridge',
                    x: bounds.left,
                    y: -30,
                    width: bounds.right - bounds.left,
                    height: 24,
                    health: 3,
                    points: 500,
                    gapLeft: bounds.left + (bounds.right - bounds.left) * 0.35,
                    gapRight: bounds.left + (bounds.right - bounds.left) * 0.65
                });
            }

            draw(ctx) {
                this.enemies.forEach(e => {
                    switch (e.type) {
                        case 'helicopter':
                            this.drawHelicopter(ctx, e);
                            break;
                        case 'ship':
                            this.drawShip(ctx, e);
                            break;
                        case 'fuel':
                            this.drawFuelDepot(ctx, e);
                            break;
                        case 'bridge':
                            this.drawBridge(ctx, e);
                            break;
                        case 'jet':
                            this.drawJet(ctx, e);
                            break;
                    }
                });
            }

            // v3: Atari 2600 pixel art helicopter
            drawHelicopter(ctx, e) {
                drawPixelSprite(ctx, SPRITE_HELI, HELI_COLORS, e.x, e.y, PX);

                // Animated rotor blade extending from the yellow rotor pixels
                ctx.fillStyle = COLORS.HELICOPTER_BLADE;
                const rotorY = e.y + 1;
                const rotorCx = e.x + 8;
                const bladeLen = 12;
                const bx = Math.cos(e.bladeAngle) * bladeLen;
                ctx.fillRect(rotorCx - Math.abs(bx), rotorY, Math.abs(bx) * 2, 2);
            }

            // v3: Atari 2600 pixel art ship
            drawShip(ctx, e) {
                drawPixelSprite(ctx, SPRITE_SHIP, SHIP_COLORS, e.x, e.y, PX);
            }

            // v3: Atari 2600 pixel art fuel depot
            drawFuelDepot(ctx, e) {
                drawPixelSprite(ctx, SPRITE_FUEL, FUEL_COLORS, e.x, e.y, PX);
            }

            drawBridge(ctx, e) {
                // Brown plank bridge with yellow center road lines (authentic)
                ctx.fillStyle = COLORS.BRIDGE;
                ctx.fillRect(e.x, e.y, e.gapLeft - e.x, e.height);
                ctx.fillRect(e.gapRight, e.y, e.x + e.width - e.gapRight, e.height);
                // Dark brown plank lines
                ctx.fillStyle = COLORS.BRIDGE_DETAIL;
                for (let x = e.x; x < e.gapLeft; x += 8) {
                    ctx.fillRect(x, e.y + 2, 4, 2);
                    ctx.fillRect(x + 2, e.y + e.height - 4, 4, 2);
                }
                for (let x = e.gapRight; x < e.x + e.width; x += 8) {
                    ctx.fillRect(x, e.y + 2, 4, 2);
                    ctx.fillRect(x + 2, e.y + e.height - 4, 4, 2);
                }
                // Yellow center road line
                ctx.fillStyle = '#f2db4d';
                const midY = e.y + Math.floor(e.height / 2) - 1;
                ctx.fillRect(e.x, midY, e.gapLeft - e.x, 2);
                ctx.fillRect(e.gapRight, midY, e.x + e.width - e.gapRight, 2);
            }

            // v3: Atari 2600 pixel art enemy jet
            drawJet(ctx, e) {
                e.flameFlicker = (e.flameFlicker + 1) % 4;

                drawPixelSprite(ctx, SPRITE_JET, JET_COLORS, e.x, e.y, PX);

                // Engine flame below tail
                ctx.fillStyle = COLORS.JET_FLAME;
                const flameH = 3 + (e.flameFlicker % 2) * 2;
                ctx.fillRect(e.x + 12, e.y + 21, 3, flameH);
            }
        }

        // ==================== EXPLOSIONS ====================
        class ExplosionManager {
            constructor() {
                this.explosions = [];
            }

            reset() {
                this.explosions = [];
            }

            add(x, y, size = 1) {
                this.explosions.push({
                    x: x,
                    y: y,
                    frame: 0,
                    maxFrames: 20,
                    size: size
                });
            }

            update() {
                this.explosions.forEach(e => e.frame++);
                this.explosions = this.explosions.filter(e => e.frame < e.maxFrames);
            }

            draw(ctx) {
                this.explosions.forEach(e => {
                    const progress = e.frame / e.maxFrames;
                    const colorIndex = Math.floor(progress * COLORS.EXPLOSION.length);
                    const radius = (1 - progress) * 25 * e.size;

                    ctx.fillStyle = COLORS.EXPLOSION[Math.min(colorIndex, COLORS.EXPLOSION.length - 1)];

                    ctx.beginPath();
                    ctx.arc(e.x, e.y, radius, 0, Math.PI * 2);
                    ctx.fill();

                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + progress * 2;
                        const dist = progress * 30 * e.size;
                        const px = e.x + Math.cos(angle) * dist;
                        const py = e.y + Math.sin(angle) * dist;
                        const pSize = (1 - progress) * 8 * e.size;
                        ctx.fillRect(px - pSize/2, py - pSize/2, pSize, pSize);
                    }
                });
            }
        }

        // ==================== TOUCH CONTROLS (v2) ====================
        class TouchControls {
            constructor(canvas) {
                this.canvas = canvas;
                this.active = false;
                this.moveLeft = false;
                this.moveRight = false;
                this.speedUp = false;
                this.speedDown = false;
                this.shoot = false;
                this.shootTap = false;
                this.touches = {};

                this.isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

                canvas.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                canvas.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                canvas.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });
                canvas.addEventListener('touchcancel', (e) => this.onTouchEnd(e), { passive: false });
            }

            getCanvasPos(touch) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = CONFIG.CANVAS_WIDTH / rect.width;
                const scaleY = CONFIG.CANVAS_HEIGHT / rect.height;
                return {
                    x: (touch.clientX - rect.left) * scaleX,
                    y: (touch.clientY - rect.top) * scaleY
                };
            }

            onTouchStart(e) {
                e.preventDefault();
                this.active = true;
                for (const touch of e.changedTouches) {
                    const pos = this.getCanvasPos(touch);
                    this.touches[touch.identifier] = pos;
                }
                this.updateFromTouches();

                for (const touch of e.changedTouches) {
                    const pos = this.getCanvasPos(touch);
                    const cx = CONFIG.CANVAS_WIDTH / 2;
                    if (Math.abs(pos.x - cx) < CONFIG.CANVAS_WIDTH * 0.15 &&
                        pos.y > CONFIG.CANVAS_HEIGHT * 0.2 && pos.y < CONFIG.CANVAS_HEIGHT * 0.8) {
                        this.shootTap = true;
                    }
                }
            }

            onTouchMove(e) {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    const pos = this.getCanvasPos(touch);
                    this.touches[touch.identifier] = pos;
                }
                this.updateFromTouches();
            }

            onTouchEnd(e) {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    delete this.touches[touch.identifier];
                }
                this.updateFromTouches();
                if (Object.keys(this.touches).length === 0) {
                    this.active = false;
                }
            }

            updateFromTouches() {
                this.moveLeft = false;
                this.moveRight = false;
                this.speedUp = false;
                this.speedDown = false;
                this.shoot = this.shootTap;
                this.shootTap = false;

                const cx = CONFIG.CANVAS_WIDTH / 2;

                for (const id in this.touches) {
                    const pos = this.touches[id];

                    if (pos.x < cx * 0.7) {
                        this.moveLeft = true;
                    } else if (pos.x > cx * 1.3) {
                        this.moveRight = true;
                    } else {
                        this.shoot = true;
                    }

                    if (pos.y < CONFIG.CANVAS_HEIGHT * 0.33) {
                        this.speedUp = true;
                    } else if (pos.y > CONFIG.CANVAS_HEIGHT * 0.67) {
                        this.speedDown = true;
                    }
                }
            }

            getInput() {
                if (!this.active) return null;
                return {
                    moveLeft: this.moveLeft,
                    moveRight: this.moveRight,
                    speedUp: this.speedUp,
                    speedDown: this.speedDown,
                    shoot: this.shoot
                };
            }

            draw(ctx) {
                if (!this.isTouchDevice) return;

                ctx.globalAlpha = 0.12;
                const cx = CONFIG.CANVAS_WIDTH / 2;
                const h = CONFIG.CANVAS_HEIGHT;

                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 45, cx * 0.7, h - 45);
                ctx.fillRect(cx * 1.3, 45, CONFIG.CANVAS_WIDTH - cx * 1.3, h - 45);

                ctx.fillStyle = '#ff4444';
                ctx.fillRect(cx * 0.7, h * 0.33, cx * 0.6, h * 0.34);

                ctx.globalAlpha = 0.35;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 18px Courier New';
                ctx.textAlign = 'center';

                ctx.fillText('◄', cx * 0.35, h * 0.55);
                ctx.fillText('►', cx * 1.65, h * 0.55);
                ctx.fillStyle = '#ff6666';
                ctx.fillText('FIRE', cx, h * 0.52);

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Courier New';
                ctx.fillText('▲ FAST', cx, h * 0.12);
                ctx.fillText('▼ SLOW', cx, h * 0.92);

                ctx.textAlign = 'left';
                ctx.globalAlpha = 1;
            }
        }

        // ==================== HUD ====================
        class HUD {
            draw(ctx, state, highScore) {
                ctx.fillStyle = COLORS.HUD_BG;
                ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, 44);

                ctx.fillStyle = COLORS.HUD_TEXT;
                ctx.font = 'bold 14px Courier New';
                ctx.fillText(`SCORE: ${state.score}`, 10, 16);

                ctx.fillStyle = '#555555';
                ctx.font = '10px Courier New';
                ctx.fillText(`HI: ${highScore}`, 10, 30);

                if (state.sectionFlash > 0) {
                    ctx.fillStyle = Math.floor(state.sectionFlash / 4) % 2 ? '#ffff44' : '#ff8800';
                } else {
                    ctx.fillStyle = '#44ddff';
                }
                ctx.font = 'bold 14px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(`SECTION ${state.section}`, CONFIG.CANVAS_WIDTH / 2, 38);
                ctx.textAlign = 'left';

                ctx.fillStyle = COLORS.HUD_TEXT;
                ctx.font = 'bold 14px Courier New';
                ctx.fillText('LIVES:', CONFIG.CANVAS_WIDTH - 120, 20);
                for (let i = 0; i < state.lives; i++) {
                    ctx.fillStyle = COLORS.PLAYER;
                    ctx.beginPath();
                    ctx.moveTo(CONFIG.CANVAS_WIDTH - 60 + i * 20, 10);
                    ctx.lineTo(CONFIG.CANVAS_WIDTH - 66 + i * 20, 24);
                    ctx.lineTo(CONFIG.CANVAS_WIDTH - 54 + i * 20, 24);
                    ctx.fill();
                }

                const fuelWidth = 120;
                const fuelHeight = 10;
                const fuelX = CONFIG.CANVAS_WIDTH / 2 - fuelWidth / 2;
                const fuelY = CONFIG.CANVAS_HEIGHT - 20; // Bottom of screen (Atari 2600 authentic)

                ctx.fillStyle = '#000000';
                ctx.fillRect(fuelX - 2, fuelY - 2, fuelWidth + 4, fuelHeight + 4);

                let fuelColor = COLORS.FUEL_FULL;
                if (state.fuel < 50) fuelColor = COLORS.FUEL_MED;
                if (state.fuel < 25) fuelColor = COLORS.FUEL_LOW;

                ctx.fillStyle = fuelColor;
                ctx.fillRect(fuelX, fuelY, (state.fuel / 100) * fuelWidth, fuelHeight);

                ctx.fillStyle = COLORS.HUD_TEXT;
                ctx.font = '9px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('FUEL', CONFIG.CANVAS_WIDTH / 2, fuelY + 9);
                ctx.textAlign = 'left';

                ctx.fillStyle = '#555555';
                ctx.font = '10px Courier New';
                ctx.fillText(`SEC ${state.section} | DIFF ${state.difficulty}`, CONFIG.CANVAS_WIDTH - 140, 38);
            }
        }

        // ==================== COLLISION DETECTION ====================
        function checkCollision(a, b) {
            return a.x < b.x + b.width &&
                   a.x + a.width > b.x &&
                   a.y < b.y + b.height &&
                   a.y + a.height > b.y;
        }

        function checkBridgeCollision(player, bridge) {
            const playerBounds = player.getBounds();
            if (playerBounds.y < bridge.y + bridge.height &&
                playerBounds.y + playerBounds.height > bridge.y) {
                const playerCenterX = playerBounds.x + playerBounds.width / 2;
                if (playerCenterX < bridge.gapLeft || playerCenterX > bridge.gapRight) {
                    return true;
                }
            }
            return false;
        }

        // ==================== MAIN GAME ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlay');
        const startScreen = document.getElementById('startScreen');
        const pauseScreen = document.getElementById('pauseScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const highScoreDisplay = document.getElementById('highScoreDisplay');
        const finalScore = document.getElementById('finalScore');
        const newHighScore = document.getElementById('newHighScore');

        canvas.width = CONFIG.CANVAS_WIDTH;
        canvas.height = CONFIG.CANVAS_HEIGHT;

        const audio = new AudioEngine();
        const state = new GameState();
        const player = new Player();
        const river = new RiverGenerator();
        const enemies = new EnemyManager();
        const explosions = new ExplosionManager();
        const hud = new HUD();
        const touchControls = new TouchControls(canvas);

        const keys = {};
        let highScore = parseInt(localStorage.getItem('riverRaidHighScore') || '0');
        let lastIslandSection = 0;

        // v3: Speed settings sliders
        const scrollSpeedSlider = document.getElementById('scrollSpeedSlider');
        const bulletSpeedSlider = document.getElementById('bulletSpeedSlider');
        const scrollSpeedVal = document.getElementById('scrollSpeedVal');
        const bulletSpeedVal = document.getElementById('bulletSpeedVal');

        // Load saved values into sliders
        scrollSpeedSlider.value = CONFIG.BASE_SCROLL_SPEED;
        bulletSpeedSlider.value = CONFIG.BULLET_SPEED;
        scrollSpeedVal.textContent = CONFIG.BASE_SCROLL_SPEED;
        bulletSpeedVal.textContent = CONFIG.BULLET_SPEED;

        scrollSpeedSlider.addEventListener('input', () => {
            const val = parseFloat(scrollSpeedSlider.value);
            scrollSpeedVal.textContent = val.toFixed(1);
            CONFIG.BASE_SCROLL_SPEED = val;
            const ratio = val / 1.8;
            CONFIG.MAX_SCROLL_SPEED = 4 * ratio;
            CONFIG.MIN_SCROLL_SPEED = Math.max(0.3, 0.5 * ratio);
            localStorage.setItem('riverRaidScrollSpeed', val);
        });

        bulletSpeedSlider.addEventListener('input', () => {
            const val = parseFloat(bulletSpeedSlider.value);
            bulletSpeedVal.textContent = val.toFixed(1);
            CONFIG.BULLET_SPEED = val;
            localStorage.setItem('riverRaidBulletSpeed', val);
        });

        // Prevent slider touch from starting game
        document.querySelector('.settings-panel').addEventListener('touchstart', (e) => {
            e.stopPropagation();
        }, { passive: false });
        document.querySelector('.settings-panel').addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;

            if (e.code === 'Space') {
                e.preventDefault();
                if (!state.isPlaying && !state.isPaused) {
                    startGame();
                } else if (state.isGameOver) {
                    restartGame();
                }
            }

            if (e.code === 'KeyP' && state.isPlaying) {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', restartGame);

        overlay.addEventListener('touchstart', (e) => {
            // Don't start game if touching settings panel
            if (e.target.closest('.settings-panel')) return;
            e.preventDefault();
            if (!state.isPlaying && !state.isPaused && !state.isGameOver) {
                startGame();
            } else if (state.isGameOver) {
                restartGame();
            } else if (state.isPaused) {
                togglePause();
            }
        }, { passive: false });

        function startGame() {
            audio.init();
            state.reset();
            player.reset();
            river.reset();
            enemies.reset();
            explosions.reset();
            lastIslandSection = 0;
            state.isPlaying = true;
            overlay.classList.add('hidden');
            highScoreDisplay.textContent = `HIGH SCORE: ${highScore}`;
        }

        function restartGame() {
            startGame();
        }

        function togglePause() {
            state.isPaused = !state.isPaused;
            if (state.isPaused) {
                overlay.classList.remove('hidden');
                startScreen.classList.add('hidden');
                gameOverScreen.classList.add('hidden');
                pauseScreen.classList.remove('hidden');
                audio.setMuted(true);
            } else {
                overlay.classList.add('hidden');
                pauseScreen.classList.add('hidden');
                audio.setMuted(false);
            }
        }

        function gameOver() {
            state.isPlaying = false;
            state.isGameOver = true;

            if (state.score > highScore) {
                highScore = state.score;
                localStorage.setItem('riverRaidHighScore', highScore);
                newHighScore.classList.remove('hidden');
            } else {
                newHighScore.classList.add('hidden');
            }

            finalScore.textContent = `SCORE: ${state.score}`;
            overlay.classList.remove('hidden');
            startScreen.classList.add('hidden');
            pauseScreen.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            audio.setMuted(true);
        }

        function playerDeath() {
            audio.playDeath();
            explosions.add(player.x + player.width / 2, player.y + player.height / 2, 1.5);
            state.lives--;

            if (state.lives <= 0) {
                gameOver();
            } else {
                player.reset();
                state.fuel = 100;
                state.invincibilityFrames = CONFIG.INVINCIBILITY_FRAMES;
            }
        }

        function update() {
            if (!state.isPlaying || state.isPaused) return;

            state.waterPhase += state.scrollSpeed * 0.8;

            if (state.sectionFlash > 0) state.sectionFlash--;

            const touchInput = touchControls.getInput();

            if (keys['ArrowUp'] || keys['KeyW'] || (touchInput && touchInput.speedUp)) {
                state.scrollSpeed = Math.min(CONFIG.MAX_SCROLL_SPEED, state.scrollSpeed + 0.1);
            }
            if (keys['ArrowDown'] || keys['KeyS'] || (touchInput && touchInput.speedDown)) {
                state.scrollSpeed = Math.max(CONFIG.MIN_SCROLL_SPEED, state.scrollSpeed - 0.1);
            }

            audio.updateEngineSpeed(state.scrollSpeed);

            state.distanceTraveled += state.scrollSpeed;
            const distDifficulty = 1 + Math.floor(state.distanceTraveled / CONFIG.DIFFICULTY_INCREASE_INTERVAL);
            state.difficulty = Math.max(distDifficulty, state.section);

            state.fuel -= CONFIG.FUEL_DEPLETION_RATE * (state.scrollSpeed / CONFIG.BASE_SCROLL_SPEED);
            if (state.fuel <= 0) {
                state.fuel = 0;
                playerDeath();
                return;
            }

            if (state.fuel < 25) {
                state.fuelWarningTimer++;
                if (state.fuelWarningTimer >= 30) {
                    state.fuelWarningTimer = 0;
                    audio.playFuelWarning();
                }
            }

            if (state.invincibilityFrames > 0) {
                state.invincibilityFrames--;
            }

            const riverBounds = river.getRiverBoundsAtY(player.y + player.height / 2);

            river.update(state.scrollSpeed, state.difficulty, state.section);
            player.update(keys, riverBounds.left, riverBounds.right, touchInput);
            enemies.update(state.scrollSpeed, state.difficulty, river, state.section);
            explosions.update();

            if (state.section - lastIslandSection >= CONFIG.ISLAND_INTERVAL) {
                river.spawnIsland();
                lastIslandSection = state.section;
            }

            if (state.invincibilityFrames === 0) {
                const playerBounds = player.getBounds();
                const topBounds = river.getRiverBoundsAtY(playerBounds.y);
                const bottomBounds = river.getRiverBoundsAtY(playerBounds.y + playerBounds.height);

                if (playerBounds.x < topBounds.left || playerBounds.x + playerBounds.width > topBounds.right ||
                    playerBounds.x < bottomBounds.left || playerBounds.x + playerBounds.width > bottomBounds.right) {
                    playerDeath();
                    return;
                }

                if (river.isInsideIsland(playerBounds.x, playerBounds.y, playerBounds.width, playerBounds.height)) {
                    playerDeath();
                    return;
                }
            }

            const playerBounds = player.getBounds();
            enemies.enemies.forEach(e => {
                if (state.invincibilityFrames === 0) {
                    if (e.type === 'bridge') {
                        if (checkBridgeCollision(player, e)) {
                            playerDeath();
                            return;
                        }
                    } else if (checkCollision(playerBounds, e)) {
                        if (e.isFuel) {
                            state.fuel = Math.min(100, state.fuel + 30);
                            audio.playRefuel();
                            state.score += e.points;
                            explosions.add(e.x + e.width / 2, e.y + e.height / 2, 0.5);
                            e.health = 0;
                        } else {
                            playerDeath();
                            return;
                        }
                    }
                }
            });

            player.bullets.forEach(bullet => {
                enemies.enemies.forEach(e => {
                    if (e.health > 0) {
                        if (e.type === 'bridge') {
                            const leftSection = { x: e.x, y: e.y, width: e.gapLeft - e.x, height: e.height };
                            const rightSection = { x: e.gapRight, y: e.y, width: e.x + e.width - e.gapRight, height: e.height };

                            if (checkCollision(bullet, leftSection) || checkCollision(bullet, rightSection)) {
                                e.health--;
                                bullet.y = -100;
                                audio.playEnemyHit();

                                if (e.health <= 0) {
                                    state.score += e.points;
                                    explosions.add(e.x + e.width / 2, e.y + e.height / 2, 2);
                                    audio.playBridgeDestroy();
                                    state.section++;
                                    state.sectionFlash = 60;
                                    audio.playSectionComplete();
                                }
                            }
                        } else if (checkCollision(bullet, { x: e.x, y: e.y, width: e.width, height: e.height })) {
                            e.health--;
                            bullet.y = -100;
                            audio.playEnemyHit();

                            if (e.health <= 0) {
                                state.score += e.points;
                                explosions.add(e.x + e.width / 2, e.y + e.height / 2);

                                if (e.type === 'jet') {
                                    audio.playJetDestroy();
                                } else if (e.type === 'helicopter') {
                                    audio.playHelicopterDestroy();
                                } else {
                                    audio.playExplosion();
                                }
                            }
                        }
                    }
                });
            });

            enemies.enemies = enemies.enemies.filter(e => e.health > 0);
            player.bullets = player.bullets.filter(b => b.y > -CONFIG.BULLET_HEIGHT);
        }

        function draw() {
            ctx.fillStyle = COLORS.SKY;
            ctx.fillRect(0, 0, CONFIG.CANVAS_WIDTH, CONFIG.CANVAS_HEIGHT);

            river.draw(ctx, state.waterPhase);
            enemies.draw(ctx);
            player.draw(ctx, state.invincibilityFrames > 0);
            explosions.draw(ctx);

            touchControls.draw(ctx);

            hud.draw(ctx, state, highScore);
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        highScoreDisplay.textContent = `HIGH SCORE: ${highScore}`;
        gameLoop();
    </script>
</body>
</html>
